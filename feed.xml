<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://imcloudfloating.github.io/blog/</id><title>Cloud</title><subtitle>Blog, Web, Java, Linux, Spring Boot.</subtitle> <updated>2022-03-13T17:34:22+08:00</updated> <author> <name>Cloud Li</name> <uri>https://imcloudfloating.github.io/blog/</uri> </author><link rel="self" type="application/atom+xml" href="https://imcloudfloating.github.io/blog/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://imcloudfloating.github.io/blog/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Cloud Li </rights> <icon>/blog/assets/img/favicons/favicon.ico</icon> <logo>/blog/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Vue3 渲染函数与代理对象踩坑记录</title><link href="https://imcloudfloating.github.io/blog/posts/Vue3-%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" rel="alternate" type="text/html" title="Vue3 渲染函数与代理对象踩坑记录" /><published>2021-11-23T17:00:00+08:00</published> <updated>2022-01-03T17:44:40+08:00</updated> <id>https://imcloudfloating.github.io/blog/posts/Vue3-%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id> <content src="https://imcloudfloating.github.io/blog/posts/Vue3-%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" /> <author> <name>Cloud Li</name> </author> <category term="Vue" /> <category term="前端" /> <summary> 本文的示例基于 TypeScript 和 vue-class-component 假设有一个第三方组件的 option 属性，它包含了一个渲染函数： export default class Foo extends Vue { @Prop(Number) private prop: number = 0 private option = { render: (arg: any) =&amp;gt; h("button", { onClick: () =&amp;gt; this.click(arg) // 这里的 this 是原始的 Foo 对象 }, {default: () =&amp;gt; "点我"}) } click(arg: any) { console... </summary> </entry> <entry><title>CMake 快速入门</title><link href="https://imcloudfloating.github.io/blog/posts/CMake-%E5%85%A5%E9%97%A8/" rel="alternate" type="text/html" title="CMake 快速入门" /><published>2021-10-11T13:00:00+08:00</published> <updated>2021-10-11T13:00:00+08:00</updated> <id>https://imcloudfloating.github.io/blog/posts/CMake-%E5%85%A5%E9%97%A8/</id> <content src="https://imcloudfloating.github.io/blog/posts/CMake-%E5%85%A5%E9%97%A8/" /> <author> <name>Cloud Li</name> </author> <category term="CMake" /> <category term="C" /> <summary> 单源文件配置 假设有 main.c 文件： #include &amp;lt;stdio.h&amp;gt; int main() { printf("Hello, World!"); return 0; } CMakeList.txt 内容： # 设置 CMake 最低版本要求 cmake_minimum_required(VERSION 3.0) # 项目名称 project(HelloWorld) set(CMAKE_C_STANDARD 11) # 指定 C 标准 # 指定生成可执行文件 add_executable(HelloWorld main.c) 以上内容就是最简单的单文件项目的配置了。 多源文件/多目录配置 假设我们需要把头文件和源文件分开存放，并且有多个生成目标： . ├── CMakeList.txt ├── include │   ├... </summary> </entry> <entry><title>Steam for Linux 设置代理</title><link href="https://imcloudfloating.github.io/blog/posts/Steam-for-Linux-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/" rel="alternate" type="text/html" title="Steam for Linux 设置代理" /><published>2020-09-30T16:00:00+08:00</published> <updated>2020-09-30T16:00:00+08:00</updated> <id>https://imcloudfloating.github.io/blog/posts/Steam-for-Linux-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</id> <content src="https://imcloudfloating.github.io/blog/posts/Steam-for-Linux-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/" /> <author> <name>Cloud Li</name> </author> <category term="Linux" /> <category term="Steam" /> <summary> 用正确的姿势给 Steam for Linux 设置代理 为什么会有此文档？ 在使用 Linux Mint 时，发现 Steam 客户端打不开社区，但是 Chrome 可以打开，于是去找 Steam 客服， 得到的回复是让我使用 Ubuntu，行吧，反正我正好有换 Ubuntu 的打算（Mint 的字体渲染不清晰）。 然而，Ubuntu 的 Steam 客户端依然打不开社区，客服说让去 GitHub 讨论，然后我分析了一下，破案了： 国内是无法访问 Steam 社区的，需要挂梯子（我确实挂了） Steam for Windows 默认使用 IE 的代理，因此，挂梯子有效 Steam for Linux 不能使用代理，也无法通过客户端设置 解决方案（1） 既然 Steam 不能设置代理，那就用第三方的工具让它走代理咯～ 1. 安装 proxychains ... </summary> </entry> <entry><title>Docker 实战—使用 Dockerfile 构建镜像</title><link href="https://imcloudfloating.github.io/blog/posts/Docker%E5%AE%9E%E6%88%98-%E4%BD%BF%E7%94%A8-Dockerfile-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/" rel="alternate" type="text/html" title="Docker 实战—使用 Dockerfile 构建镜像" /><published>2019-11-03T17:00:00+08:00</published> <updated>2022-01-03T17:44:40+08:00</updated> <id>https://imcloudfloating.github.io/blog/posts/Docker%E5%AE%9E%E6%88%98-%E4%BD%BF%E7%94%A8-Dockerfile-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/</id> <content src="https://imcloudfloating.github.io/blog/posts/Docker%E5%AE%9E%E6%88%98-%E4%BD%BF%E7%94%A8-Dockerfile-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/" /> <author> <name>Cloud Li</name> </author> <category term="Docker" /> <summary> 使用 Alpine Linux 作为基础镜像 Alpine 是一个非常轻量的 Linux 镜像，他只有大约 5MB 的大小，基于它构建镜像，可以大大减少镜像的体积。 docker pull alpine Alpine 使用 apk 命令来安装软件包，支持的软件包列表可以在官网查看：https://pkgs.alpinelinux.org/packages 这里以安装 Nginx 为例，学习镜像的构建。另外 Nginx 本身有官方镜像，pull 即可。 构建 Nginx 镜像 编写 Dockerfile FROM alpine RUN apk update \ # 安装 nginx apk add --no-cache nginx \ mkdir /run/nginx &amp;amp;&amp;amp; \ # 清除缓存 rm -rf /tm... </summary> </entry> <entry><title>Dockerfile 指令详解</title><link href="https://imcloudfloating.github.io/blog/posts/Dockerfile-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/" rel="alternate" type="text/html" title="Dockerfile 指令详解" /><published>2019-10-24T21:00:00+08:00</published> <updated>2019-10-24T21:00:00+08:00</updated> <id>https://imcloudfloating.github.io/blog/posts/Dockerfile-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</id> <content src="https://imcloudfloating.github.io/blog/posts/Dockerfile-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/" /> <author> <name>Cloud Li</name> </author> <category term="Docker" /> <summary> FROM FROM 命令指定基础镜像。在构建镜像时，基础镜像必须指定，因此在 Dockerfile 中 FROM 是必备指令且必须是第一条指令。 在 Docker Hub 上有很多常用的高质量官方镜像，有一些是应用和服务类的镜像，如 nginx、mysql、redis 等；也有一些是用于运行各种语言应用的镜像，如 openjdk、python、node 等。 如果找不到应用的官方镜像，可以基于操作系统镜像构建一个。Docker Hub 上提供了很多操作系统镜像。 FROM ubuntu ... RUN RUN 指令是用来执行命令行命令的。RUN 指令的格式有两种： shell 格式：RUN &amp;lt;命令&amp;gt;，就像直接在命令行中输入命令一样。 RUN java -jar app.jar exec 格式：RU... </summary> </entry> </feed>
